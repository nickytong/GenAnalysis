% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aheatmat.R
\name{aheatmat}
\alias{aheatmat}
\title{annotated heatmap using heatmat engine}
\usage{
aheatmat(mat, pheno = NULL, gSel = NULL, sSel0 = NULL, sSel1 = NULL,
  colOrderIndex = NULL, rowOrderIndex = NULL, scale = "row",
  clusterWithScaledData = FALSE, cluster_rows = TRUE, cluster_cols = TRUE,
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation", clustering_method = "ward.D",
  truncate = NA, q1 = 0.01, q2 = 0.99, Lower = NULL, Upper = NULL,
  cexRow = NULL, cexCol = NULL, labCol = NULL, labRow = NULL,
  colbar = NULL, rowbar = NULL, color = colorpalette2colvec("bluered"),
  ncolor = 60, colBarSel = NULL, y0 = 1, x0 = 0.8, yd = 0.17,
  oma = c(0, 1, 3, 11) + 0.1, plot = TRUE, colpal = NULL, rowpal = NULL,
  gpheno = NULL, plotLegend = TRUE, labRowcolor = NULL, ...)
}
\arguments{
\item{mat}{matrix for heatmap}

\item{pheno}{a data frame where columns represent different column bars (in a heatmap)
notice: always do not subset pheno!}

\item{gSel}{gene selection. This can be index or gene names. Internally, both will be converted to integer based index (global or local)}

\item{sSel0}{sample selection filter 0; by default, this deals with augMat to remove all NA columns
the user can override this by supplying a vector of indeces or sample names.}

\item{sSel1}{sample selection (index or sample names). This is useful to select a subset of samples based
on phenotype, i.e. some mutation, like ++ to be removed}

\item{colOrderIndex}{index/sample names to order column; The actual number of samples surviving is an intersect between colOrderIndex and sSel (from sSel0 and sSel1).
if not specified, column clustering will be instructed to construct; otherwise, no clumn clustering will be done later on}

\item{rowOrderIndex}{index (integer or gene names) to order rows; The actual genes surviving is an intersect between rowOrderIndex and gSel.
if not specified, row clustering will be instructed to construct; otherwise, no row clustering will be done later on. To disable row clustering, need to specify rowOrderIndex and cluster_rows=FALSE simultaneously}

\item{scale}{selection from c("none", "row", "column")}

\item{clusterWithScaledData}{logical indicating if use scaled data for clustering; default is FALSE}

\item{cluster_rows}{whether to cluster rows}

\item{cluster_cols}{whether to cluster columns}

\item{clustering_distance_rows}{distance metric for rows}

\item{clustering_distance_cols}{distance metric for cols}

\item{clustering_method}{clustering method}

\item{truncate}{logical indicating if truncation is needed; default is NA will enable truncate if scale!='none'}

\item{q1}{parameter q1 to truncByLimit}

\item{q2}{parameter q2 to truncByLimit}

\item{Lower}{parameter Lower to truncByQuantile()}

\item{Upper}{parameter Upper to truncByQuantile()}

\item{colbar}{column bar object as returned by prepcolbar(): need to add option for colbar=NULL, no colbar case}

\item{rowbar}{row bar object as returned by prepcolbar(). Default is NULL, meaning no rowbar}

\item{color}{color vector for expression data}

\item{ncolor}{number of colors to be interpolated based on color parameter}

\item{colBarSel}{a vector to select a subset of column bars; this should be a subset of colnames of pheno data (also colnames of colbar)}

\item{oma}{oma passed to par()}

\item{plot}{whether to plot the heatmap}

\item{colpal}{user specified column-wise color palette (a named list of color vector); only shared names will be used to update default colpal. Default is NULL
thus no updates at all, only focusing on default}

\item{rowpal}{user specified row-wise color palette (a named list of color vector); only shared names will be used to update default rowpal. Default is NULL
thus no updates at all, only focusing on default}

\item{gpheno}{a one-column gene annotation data frame. (need more work to include multiple row bars and check indexing)}

\item{plotLegend}{whether to plot color legend}

\item{...}{additional parameters to heatmat}
}
\value{
mapL list with additional attributes to reconstruct heatmap (returned by plotHeatmap, a phm class)
}
\description{
annotated heatmap using heatmat engine
}

